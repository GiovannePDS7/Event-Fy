               break # Exit returning the error message
                    else:
                        time.sleep(0.3)
                    _msg = msg
                    if type(msg) is tuple:
                        msg = '\n' + ''.join(traceback.format_exception(*msg))
                        _msg = str(_msg[1])
                    log_debug("%s: %s\n" % (msg_type, msg))
                    if msg_type == 'ERROR':
                        error = _msg
                        break  # Exit returning the error message
                
                if (not tunnel.is_connecting() or not tunnel.isAlive()) and tunnel.q.empty():  
                    break
                time.sleep(0.3)
        log_debug("returning from wait_connection(%s): %s\n" % (port, error))
        # we need to close tunnel so it get opened again, without it we may have problems later
        if close_tunnel:
            tunnel.close()
            del self.tunnel_by_port[port]
        return error


    def get_message(self, port):
        if port not in self.tunnel_by_port:
            log_error("Looking up invalid port %s\n" % port)
            return None
        tunnel = self.tunnel_by_port[port]
        try:
            return tunnel.q.get_nowait()
        except queue.Empty:
            return None


    def set_keepalive(self, port, keepalive):
        if keepalive == 0:
            log_info("SSH KeepAlive setting skipped.\n")
            return
        tunnel = self.tunnel_by_port.get(port)
        if not tunnel:
            log_error("Looking up invalid port %s\n" % port)
            return
        transport = tunnel._client.get_transport()
        if transport is None:
            log_error("SSHTransport not ready yet %d\n" % port)
            return

        transport.set_keepalive(keepalive)

    def close(self, port):
        pass
        # tunnels auto-close when inactive
        #tunnel = self.tunnel_by_port.get(port, None)
        #if tunnel:
        #    tunnel.num_clients -= 1
        #    if tunnel.num_clients == 0:
        #        tunnel.close()
        #        del self.tunnel_by_port[port]

    def send(self, code, arg=''):
        if arg:
            self.outpipe.write(code + ' ' + arg + '\n')
        else:
            self.outpipe.write(code + '\n')
        self.outpipe.flush()
    
    def shutdown(self):
        for tunnel in list(self.tunnel_by_port.values()):
            tunnel.close()
            tunnel.join()

    # FIXME: It seems that this function is never called. Should we remove it?
    def wait_requests(self):
        #print "SSH Tunnel Manager started, waiting for requests..."
        self.send("READY")
        while True:
            request = self.inpipe.readline()
            if not request:
                #print "Exiting tunnel manager..."
                break
            try:
                cmd, args = eval(request, {}, {})
            except:
                self.send("ERROR", "Invalid request")
                continue
            if cmd == "LOOKUP":
                try:
                    port = self.lookup_tunnel(*args)
                    if port is not None:
                        self.send("OK", str(port))
                    else:
                        self.send("ERROR", "not found")
                except Exception as exc:
                    self.send("ERROR", str(exc))
            elif cmd == "OPENSSH":
                try:
                    port = self.open_ssh(*args)
                    self.send("OK", str(port))
                except Exception as exc:
                    self.send("ERROR", str(exc))
            elif cmd == "CLOSE":
                #self.close(args[0])
                self.send("OK")
            elif cmd == "WAIT":
                # wait for the SSH connection to be established
                error = self.wait_connection(args)
                if not error:
                    self.send("OK")
                else:
                    self.send("ERROR "+error)
            elif cmd == "MESSAGE":
                msg = self.get_message(args)
                if msg:
                    self.send(msg)
                else:
                    self.send("NONE")
            else:
                log_error("Invalid request %s\n" % request)
                self.send("ERROR", "Invalid request")

"""
if "--single" in sys.argv:
    target = sys.argv[2]
    if "-pw" in sys.argv:
        password = sys.argv[sys.argv.index("-pw")+1]
    else:
        password = None
    if "-i" in sys.argv:
        keyfile = sys.argv[sys.argv.index("-i")+1]
    else:
        keyfile = None
    server = sys.argv[-1]

    tunnel = Tunnel(None, False)
    if "@" in 